/* Generated by RuntimeBrowser
   Image: /Library/Developer/CoreSimulator/Volumes/iOS_21A328/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS 17.0.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/AVFCore.framework/AVFCore
 */

@interface AVSampleBufferVideoRenderer : NSObject <AVFigVideoQueueFactory, AVMediaDataRequesterConsumer, AVQueuedSampleBufferRendering, AVQueuedSampleBufferRenderingInternal> {
    NSString * _STSLabel;
    bool  _aboveHighWaterLevel;
    bool  _addedToSynchronizer;
    AVApplicationStateMonitor * _applicationStateMonitor;
    bool  _containsDisplayLayer;
    struct OpaqueCMTimebase { } * _controlTimebaseSetByUser;
    bool  _controlTimebaseSetByUserIsInUse;
    bool  _createVideoQueueFailed;
    id  _didFinishSuspensionNotificationToken;
    bool  _disallowsVideoLayerDisplayCompositing;
    NSError * _error;
    struct __CFArray { } * _figVideoTargets;
    NSObject<OS_dispatch_queue> * _flushCallbackListQueue;
    NSObject<OS_dispatch_queue> * _flushCallbackQueue;
    NSMutableArray * _flushCallbacks;
    bool  _hasEverEnqueued;
    bool  _isRequestingMediaData;
    struct OpaqueFigCPECryptor { } * _lastCryptor;
    struct opaqueCMFormatDescription { } * _lastFormatDescription;
    NSObject<OS_dispatch_queue> * _layerQueue;
    AVMediaDataRequester * _mediaDataRequester;
    struct { 
        long long value; 
        int timescale; 
        unsigned int flags; 
        long long epoch; 
    }  _minimumUpcomingPTS;
    bool  _outputObscured;
    id /* block */  _pendingPrerollCompleteCallback;
    int  _pendingPrerollRequestID;
    bool  _preventsAutomaticBackgroundingDuringVideoPlayback;
    bool  _preventsDisplaySleepDuringVideoPlayback;
    struct CGRect { 
        struct CGPoint { 
            double x; 
            double y; 
        } origin; 
        struct CGSize { 
            double width; 
            double height; 
        } size; 
    }  _previousSourceRect;
    NSObject<OS_dispatch_queue> * _queueForCallingPrerollCompleteCallback;
    NSObject<OS_dispatch_queue> * _queueForProtectingPrerollCompleteCallback;
    struct OpaqueCMTimebase { } * _readOnlyRenderingTimebase;
    struct OpaqueCMTimebase { } * _readOnlyVideoQueueTimebase;
    bool  _requiresFlushToResumeDecoding;
    NSObject<OS_dispatch_queue> * _serialQueue;
    long long  _status;
    int  _upcomingPTSExpectation;
    NSMutableArray * _videoOutputs;
    struct OpaqueFigVideoQueue { } * _videoQueue;
    NSObject<OS_dispatch_queue> * _videoQueueQueue;
    AVContentKeySession * _weakContentKeySession;
    AVSampleBufferDisplayLayer * _weakDisplayLayer;
    AVSampleBufferRenderSynchronizer * _weakReferenceToSynchronizer;
}

@property (getter=_STSLabel, nonatomic, copy) NSString *STSLabel;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (getter=_disallowsVideoLayerDisplayCompositing, setter=_setDisallowsVideoLayerDisplayCompositing:) bool disallowsVideoLayerDisplayCompositing;
@property (readonly) NSError *error;
@property (nonatomic, readonly) bool hasSufficientMediaDataForReliablePlaybackStart;
@property (readonly) unsigned long long hash;
@property (readonly) bool outputObscuredDueToInsufficientExternalProtection;
@property (nonatomic, readonly) NSArray *outputs;
@property (nonatomic) bool preventsAutomaticBackgroundingDuringVideoPlayback;
@property (nonatomic) bool preventsCapture;
@property (nonatomic) bool preventsDisplaySleepDuringVideoPlayback;
@property (getter=isReadyForMoreMediaData, readonly) bool readyForMoreMediaData;
@property (readonly) bool requiresFlushToResumeDecoding;
@property (readonly) long long status;
@property (readonly) Class superclass;
@property (readonly, retain) struct OpaqueCMTimebase { }*timebase;

+ (bool)automaticallyNotifiesObserversForKey:(id)arg1;
+ (void)initialize;

- (void).cxx_destruct;
- (id)_STSLabel;
- (id)_STSLabelPublisher;
- (void)_addFigVideoQueueListeners;
- (void)_callOldPrerollCompletionHandlerWithSuccess:(bool)arg1 andSetNewPrerollCompletionHandler:(id /* block */)arg2 forRequestID:(int)arg3;
- (void)_completedDecodeForPrerollForRequestID:(int)arg1;
- (struct { struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_2_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_2_1_2; } x2; })_computeSampleBufferEnqueueingInfoForSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1;
- (struct OpaqueFigVideoQueue { }*)_copyVideoQueue;
- (int)_createVideoQueue:(struct OpaqueFigVideoQueue {}**)arg1 errorStep:(id*)arg2;
- (bool)_createVideoQueueFailed;
- (void)_didFinishSuspension:(id)arg1;
- (id)_displayLayer;
- (int)_enqueueSingleSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_2_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_2_1_2; } x2; }*)arg2;
- (void)_flushComplete;
- (bool)_hasEverEnqueued;
- (int)_initializeTimebases;
- (bool)_isCreateVideoQueueErrorRetryable:(int)arg1;
- (struct OpaqueCMTimebase { }*)_readOnlyVideoQueueTimebase;
- (void)_refreshAboveHighWaterLevel;
- (void)_removeFigVideoQueueListeners;
- (void)_resetStatusWithOSStatus:(int)arg1;
- (int)_setContentLayerOnFigVideoQueue:(struct OpaqueFigVideoQueue { }*)arg1;
- (void)_setCreateVideoQueueFailedWithOSStatus:(int)arg1;
- (void)_setOutputObscuredDueToInsufficientExternalProtection:(bool)arg1;
- (void)_setRequiresFlushToResumeDecoding:(bool)arg1;
- (void)_setStatus:(long long)arg1 error:(id)arg2;
- (bool)_setSynchronizerTimebase:(struct OpaqueCMTimebase { }*)arg1 error:(id*)arg2;
- (id)_statusString:(long long)arg1;
- (void)_updateVideoTargetsOnVideoQueue;
- (void)addSampleBufferDisplayLayer:(id)arg1;
- (void)addVideoTarget:(struct OpaqueFigVideoTarget { }*)arg1;
- (int)attachToContentKeySession:(id)arg1 contentKeyBoss:(struct CMBaseObject { }*)arg2 failedSinceAlreadyAttachedToAnotherSession:(bool*)arg3;
- (bool)attachedToExternalContentKeySession;
- (id)contentKeySession;
- (struct OpaqueCMTimebase { }*)controlTimebase;
- (void)copyFigSampleBufferAudioRenderer:(struct OpaqueFigSampleBufferAudioRenderer {}**)arg1;
- (int)createVideoQueue:(struct OpaqueFigVideoQueue {}**)arg1;
- (id)currentFigVideoQueueFactory;
- (void)dealloc;
- (id)description;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_2_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_2_1_2; } x2; }*)arg2;
- (id)error;
- (void)flush;
- (void)flushAndRemoveImage;
- (void)flushWithRemovalOfDisplayedImage:(bool)arg1 completionHandler:(id /* block */)arg2;
- (bool)hasSufficientMediaDataForReliablePlaybackStart;
- (id)init;
- (bool)isReadyForMoreMediaData;
- (void)prerollDecodeWithCompletionHandler:(id /* block */)arg1;
- (void)requestMediaDataWhenReadyOnQueue:(id)arg1 usingBlock:(id /* block */)arg2;
- (bool)requiresFlushToResumeDecoding;
- (void)setContentKeySession:(id)arg1;
- (void)setControlTimebase:(struct OpaqueCMTimebase { }*)arg1;
- (void)setDisplayLayerVisibility:(bool)arg1;
- (bool)setRenderSynchronizer:(id)arg1 error:(id*)arg2;
- (void)setSTSLabel:(id)arg1;
- (void)setToneMapToStandardDynamicRange:(bool)arg1;
- (long long)status;
- (void)stopRequestingMediaData;
- (struct OpaqueCMTimebase { }*)timebase;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererAutomaticBackgroundPrevention)

- (bool)preventsAutomaticBackgroundingDuringVideoPlayback;
- (void)setPreventsAutomaticBackgroundingDuringVideoPlayback:(bool)arg1;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererDisplayCompositing)

- (bool)_disallowsVideoLayerDisplayCompositing;
- (void)_setDisallowsVideoLayerDisplayCompositing:(bool)arg1;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererImageProtection)

- (bool)preventsCapture;
- (void)setPreventsCapture:(bool)arg1;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererOutputs)

- (void)_updateVideoOutputs;
- (void)addOutput:(id)arg1;
- (struct __CVBuffer { }*)copyDisplayedPixelBuffer;
- (id)outputs;
- (void)removeOutput:(id)arg1;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererProtectedContent)

- (bool)outputObscuredDueToInsufficientExternalProtection;

// AVSampleBufferVideoRenderer (AVSampleBufferVideoRendererVideoDisplaySleepPrevention)

- (bool)preventsDisplaySleepDuringVideoPlayback;
- (void)setPreventsDisplaySleepDuringVideoPlayback:(bool)arg1;

// AVSampleBufferVideoRenderer (PowerOptimization)

- (bool)_setUpcomingPresentationTimeExpectations:(int)arg1 minimumPresentationTime:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg2;
- (void)expectMinimumUpcomingSampleBufferPresentationTime:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg1;
- (void)expectMonotonicallyIncreasingUpcomingSampleBufferPresentationTimes;
- (void)resetUpcomingSampleBufferPresentationTimeExpectations;

// AVSampleBufferVideoRenderer (VideoPerformanceMetrics)

- (id)videoPerformanceMetrics;

@end
